<a name="9.2" />
# 9.2 在JRockit Mission Control中使用JFR

在JRockit Mission Control客户端中可以很方便的控制事件记录的生命周期，推荐使用。

在JRockit Mission Control中开启JFR事件记录很简单，在 **JVM浏览器**右键点击目标JVM，在弹出的菜单中点击"**Start Flight Recording....**"即可。

![Figure 9-2][1]

以JRockit Mission Control 4.0版本为例，在点击"**Start Flight Recording....**"菜单之后，会：

1. 弹出 **Start Flight Recording**对话框
2. 进入 **Flight Recorder Control**视图

**Flight Recorder Control**视图实在JRockit Mission Control 4.0版本中新引入的，用于展示当前可用的JVM连接中都有哪些事件记录，并对事件记录进行控制。在该视图中可以方便的查看当前有哪些正在进行的事件记录。例如在下面的截图里，可以从Flight Recorder Control视图中看出当前已经有一个事件记录正在运行：

![Figure 9-3][2]

从上面的截图中可以看出，与JRA类似，在该对话框中，可以选择一些系统内置的模板，也可以自己创建新的模板。这些模板不同于服务器端模板，可用于图形界面，并且解析过程也有所区别。

默认的客户端模板包括：

* **普通概要分析（Default Profiling）**: 以较低的执行开销执行一些通用分析的模板。
* **带有锁定的概要分析（Profiling With Locks）**: 与 **普通概要分析**相同，并额外启用了锁分析。使用该模板时，需要在启动JVM时，添加命令行参数 `-XX:+UseLockProfiling`，不过使用该命令行参数会带来一些性能损耗。
* **带有异常错误的概要分析（Profiling with Exceptions）**: 与 **普通概要分析**相同，并且启用了异常分析。对于大多数应用程序来说，使用该模板的执行开销与使用 **普通概要分析**模板没什么区别，但是对于某些会经常抛异常的应用程序来说，这个执行开销就很可观了。
* **实时（Real-Time）**: 该模板更关注与垃圾回收相关的事件，而对其他资源的饥饿事件则不予理会。

值得注意的是，默认的客户端模板和服务器端模板在默认情况下都会忽略异常事件，因为很难准确评估异常在那些烂应用程序中所产生的影响。若想对异常进行分析，请选择 **带有异常错误的概要分析**模板。有关异常的概要分析将在本章后面的内容中进行介绍。

在选择了模板之后，需要指定记录文件的存储位置，以及为该记录取个名字。某些事件发生器（例如WebLogic Diagnostics Framework）中会运行自己的事件记录。在一个大型系统中，可能会同时存在多个事件记录并行运行。因此，为事件记录取个好名字是很重要的。

>除了JVM外，还有一些其他系统也会记录事件，例如Oracle WebLogic Diagnostics Framework和Oracle
 Dynamic Monitoring系统。希望在将来的版本中可以添加更多的事件发生器。

在对话框中可以选择创建一个有时限的记录，或是一个持续记录。如果是有时限的记录，则需要指定记录的持续时间。若想限制持续记录的资源使用情况，可以对所记录数据的的大小、记录时间进行限制。

然后，点击"Continue"按钮，将会开始执行事件记录。

![Figure 9-4][3]

如截图所示，**Flight Recorder Control**视图总会显示出这个新创建的事件记录。对于有时限的记录来说，会显示出该记录的剩余时间，并定时更新；而如果是持续记录的话，则会在剩余时间处显示一个无穷大符号来。

在Flight Recorder Control视图的工具条上有一个 **表设置**按钮，可用于设置要显示哪些字段内容。

对于有时限的事件记录来说，当记录完成时，会自动下载记录内容。


从上面的截图中可以看出，在记录结束后，会在左侧列出相关记录。在截图中，名为"My Recording"的记录已经结束，剩余时间为0，并且已经下载完成。右键点击相应的记录，点击"Close"菜单即可移除某个事件记录。

则合格纳入前面提到的，在同一个JVM中，可能同时存在多个活跃的事件记录。若想在监视器中添加新的连接，只需在JVM浏览器视图右键点击目标连接。选择 **Show Recodings**菜单即可。例如，在下面的截图中，共显示了3个不同的JVM实例。

![Figure 9-6][5]

若想从正在进行的事件记录中导出数据，只需要右键点击该事件记录，选择"**Dump...**"菜单即可，在弹出的"**Dump Recording**"对话框中做下一步配置；

![Figure 9-7][6]

在转储记录时，有3中不同的方式可选：

* 整个记录: 转储所有可用数据。
* 记录的最后部分: 转储某个给定时间段内的记录的最后一部分数据。注意，有可能会得到比期望值更多的数据，因为转储的时候，会将整块数据进行转储。
* 记录间隔: 将给定时间段内的数据进行转储。注意，指定的时间是服务器时间。如果客户端在斯德哥尔摩，而服务器在东京，则请确保时间设置正确。如果在指定的时间段内没有数据，则会显示一条错误信息。

再次强调，转储得到的数据可能会比期望值多。

以 **整个记录**方式转储的数据会按照固定大小划分为多个数据块，其中的每个数据库都包含了一个常量池，用于解析数据块内的数据，例如包含在事件中的调用栈信息。当事件对象包含了调用栈信息时，就可以通过索引在常量池查找相应的事件信息。这样，每个数据块就成为了自包含的。

<a name="9.2.1" />
## 9.2.1 自定义JFR记录

在JFR记录创建对话框中可以自定义模板。单击模板名旁边的"Advanced..."按钮，可以进入到模板编辑对话框。

![Figure 9-8][7]

在对话框的左侧是事件类型树，在其中选择某个父节点进行配置后，会递归地的应用到其所有的子节点中。如果为不同的子节点做了不同的设置，则不会再父节点上显示属性值。例如，在前面的截图中，由于 **Java Application**节点下各子节点的配置不同，因此在 **Request Periodand Threshold**中不会显示数值。此外，当没有选中复选框 **Enabled**时，某些事件是被禁用的，需要的时候可以打开。

如截图所示，勾选事件类型树下面的复选框，则会过滤掉与模板无法的事件类型。若某个节点下的子节点从属于某个模板，则会以黑体字显示该节点。结果就像示意图中显示的一样，在当前模板中，**Log**节点下没有显示任何事件类型。

事件类型树中所显示的事件类型取决于当前运行的是何种应用程序（应用程序也可能会使用到JFR API），以及模板的具体配置。这种方式使用户可以自行修改有关事件类型的配置。在下面的示例中，通过对 **Log**节点下的事件类型进行配置，在事件发生器中添加了新的事件类型。

![Figure 9-9][8]

修改事件类型的属性后，会议粗体突出显示，用以指明它们是新模板的一部分。

从高级模板编辑对话框中无法导入服务器端模板，因此只好先清除掉其他相关设置，点击 **Clear**按钮即可。导入功能是附加的，因为服务器端模板本来就是要这么搞。因此，在应用的时候，就可以先从默认记录开始，在通过导入默认模板来添加锁分析，再导入锁模板。如下面的截图所示：

![Figure 9-10][9]

进入高级对话框来创建一个模板的临时拷贝，点击 **OK**按钮来保存该临时拷贝。如果在模板名旁边有星号(*)，表明该模板还没有被保存。如果只是临时针对某个记录而修改了模板，那么就不必保存了。

![Figure 9-11][10]





[1]:    ../images/9-2.jpg
[2]:    ../images/9-3.jpg
[3]:    ../images/9-4.jpg
[4]:    ../images/9-5.jpg
[5]:    ../images/9-6.jpg
[6]:    ../images/9-7.jpg
[7]:    ../images/9-8.jpg
[8]:    ../images/9-9.jpg
[9]:    ../images/9-10.jpg
[10]:   ../images/9-11.jpg